<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GRUA 시즌 퍼즐</title>
  <style>
    :root{
      --bg:#0b0f19;
      --panel: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: rgba(139, 236, 255, .95);
      --danger: rgba(255, 122, 122, .95);
      --ok: rgba(140, 255, 200, .95);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius2: 26px;
      --max: 1100px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 20% 10%, rgba(120,160,255,.12), transparent 55%),
                  radial-gradient(900px 600px at 80% 30%, rgba(140,255,200,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo";
    }
    .wrap{ max-width: var(--max); margin: 0 auto; padding: 22px 16px 60px; }
    header{ display:flex; align-items:flex-end; justify-content:space-between; gap:12px; margin-bottom: 16px; }
    .title{ display:flex; flex-direction:column; gap:6px; }
    .title h1{ margin:0; font-size: 20px; letter-spacing: .2px; }
    .title p{ margin:0; color:var(--muted); font-size: 13px; line-height: 1.35; }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 12px; border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px; font-size: 12px; color: var(--muted);
      user-select:none; white-space:nowrap;
    }
    .grid{ display:grid; grid-template-columns: 1.25fr .75fr; gap: 14px; align-items:start; }
    @media (max-width: 980px){ .grid{grid-template-columns: 1fr;} }

    .panel{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center; gap: 10px;
    }
    .panelHeader .h{ display:flex; flex-direction:column; gap: 4px; }
    .panelHeader .h b{font-size: 14px;}
    .panelHeader .h span{font-size: 12px; color:var(--muted);}
    .panelBody{ padding: 14px; }

    .campus{
      position:relative;
      aspect-ratio: 16 / 10;
      width:100%;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
      background:
        radial-gradient(600px 350px at 30% 20%, rgba(120,160,255,.10), transparent 60%),
        radial-gradient(700px 400px at 75% 45%, rgba(140,255,200,.08), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .campus::before{
      content:"";
      position:absolute; inset:0;
      background-image: url("assets/campus-bg.jpg");
      background-size: cover; background-position: center;
      opacity: .12;
      filter: saturate(.8) contrast(1.05);
      pointer-events:none;
    }
    .campus .overlay{ position:absolute; inset:0; pointer-events:none; }
    .campus svg{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }

    .node, .landmark{ position:absolute; transform: translate(-50%, -50%); pointer-events:auto; user-select:none; }
    .nodeBtn{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px; border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.55);
      backdrop-filter: blur(8px);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease, opacity .12s ease;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      min-width: 150px;
    }
    .nodeBtn:hover{ transform: translateY(-1px); border-color: rgba(139,236,255,.35); }
    .nodeDot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(255,255,255,.55);
      box-shadow: 0 0 0 6px rgba(255,255,255,.08);
      flex:0 0 auto;
    }
    .nodeText{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .nodeText b{ font-size: 12px; letter-spacing: .3px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .nodeText span{ font-size: 11px; color: var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
    .node.unlocked .nodeDot{
      background: rgba(140,255,200,.95);
      box-shadow: 0 0 0 6px rgba(140,255,200,.12);
    }
    .node.unlocked .nodeBtn{
      border-color: rgba(140,255,200,.30);
      background: rgba(10,14,24,.40);
      opacity: .88;
    }

    .lmPill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(8px);
      font-size: 12px; color: rgba(255,255,255,.80);
      pointer-events:none;
    }
    .lmIcon{
      width:10px; height:10px; border-radius: 3px;
      background: rgba(139,236,255,.70);
      box-shadow: 0 0 0 6px rgba(139,236,255,.08);
    }

    .puzzleWrap{ display:flex; flex-direction:column; gap: 10px; }
    .puzzle{
      position:relative; width:100%;
      aspect-ratio: 1 / 1;
      border-radius: var(--radius2);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      box-shadow: var(--shadow);
    }
    .puzzle img{ position:absolute; inset:0; width:100%; height:100%; object-fit:cover; transform: scale(1.02); }
    .tiles{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 2px;
      padding: 2px;
      background: rgba(255,255,255,.05);
    }
    .tile{
      position:relative;
      overflow:hidden;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.22);
    }
    .tile::before{
      content:"";
      position:absolute; inset:0;
      background-image: url("assets/puzzle.png");
      background-size: 400% 400%;
      filter: blur(16px) brightness(.8);
      opacity: .75;
      transform: scale(1.02);
    }
    .tile.revealed::before{ filter: none; opacity: 1; }

    .tile[data-i="1"]::before  { background-position: 0%   0%; }
    .tile[data-i="2"]::before  { background-position: 33.333% 0%; }
    .tile[data-i="3"]::before  { background-position: 66.666% 0%; }
    .tile[data-i="4"]::before  { background-position: 100% 0%; }
    .tile[data-i="5"]::before  { background-position: 0%   33.333%; }
    .tile[data-i="6"]::before  { background-position: 33.333% 33.333%; }
    .tile[data-i="7"]::before  { background-position: 66.666% 33.333%; }
    .tile[data-i="8"]::before  { background-position: 100% 33.333%; }
    .tile[data-i="9"]::before  { background-position: 0%   66.666%; }
    .tile[data-i="10"]::before { background-position: 33.333% 66.666%; }
    .tile[data-i="11"]::before { background-position: 66.666% 66.666%; }
    .tile[data-i="12"]::before { background-position: 100% 66.666%; }
    .tile[data-i="13"]::before { background-position: 0%   100%; }
    .tile[data-i="14"]::before { background-position: 33.333% 100%; }
    .tile[data-i="15"]::before { background-position: 66.666% 100%; }
    .tile[data-i="16"]::before { background-position: 100% 100%; }

    .sideCard{
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      background: rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .sideCard h3{ margin:0 0 6px 0; font-size: 13px; }
    .sideCard p{ margin:0; color: var(--muted); font-size: 12px; line-height: 1.45; }

    .progress{ margin-top: 10px; display:flex; align-items:center; justify-content:space-between; gap:10px; font-size: 12px; color: var(--muted); }
    .bar{
      flex:1; height: 8px; border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden; border:1px solid rgba(255,255,255,.10);
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background: linear-gradient(90deg, rgba(139,236,255,.90), rgba(140,255,200,.90));
    }

    /* Toast */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(10,14,24,.78);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.90);
      padding: 10px 12px;
      border-radius: 999px;
      box-shadow: var(--shadow);
      font-size: 12px;
      display:none;
      z-index: 60;
      backdrop-filter: blur(10px);
      max-width: min(92vw, 720px);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .toast.show{ display:block; }
    .toast.ok{ border-color: rgba(140,255,200,.28); }
    .toast.bad{ border-color: rgba(255,122,122,.30); }

    /* Modal */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      place-items:center;
      padding: 16px;
      z-index: 50;
    }
    .modalBack.show{ display:grid; }
    .modal{
      width:min(920px, 96vw);
      border-radius: 26px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.72);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalHead b{font-size: 14px;}
    .x{
      width: 34px; height: 34px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      cursor:pointer;
    }
    .x:hover{ border-color: rgba(139,236,255,.35); }
    .modalBody{
      padding: 14px 16px 16px;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 12px;
    }
    @media (max-width: 860px){
      .modalBody{ grid-template-columns: 1fr; }
    }
    .block{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 20px;
      background: rgba(255,255,255,.04);
      padding: 12px;
    }
    .k{ font-size: 11px; color: var(--muted); margin-bottom: 6px; }
    .v{ font-size: 13px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
    .formRow{ display:flex; gap:10px; margin-top:10px; }
    .inp{
      flex:1;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      outline:none;
    }
    .inp:focus{ border-color: rgba(139,236,255,.35); }
    .submit{
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(139,236,255,.10);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      cursor:pointer;
      min-width: 92px;
    }
    .submit:hover{ border-color: rgba(139,236,255,.35); }
    .submit:disabled{ opacity:.55; cursor:not-allowed; }
    .status{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .status.ok{ color: var(--ok); }
    .status.bad{ color: var(--danger); }
    .hintToggle{
      margin-top: 8px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      color: var(--muted);
      cursor:pointer;
      user-select:none;
    }
    .hintBox{ display:none; margin-top: 8px; }
    .hintBox.show{ display:block; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>GRUA · 공동 시즌 퍼즐</h1>
        <p>16개 타입 노드를 각각 해금하면 퍼즐이 완성됩니다. 로그인/닉네임/랭킹 없음. 기록보다 “해금 상태” 중심.</p>
      </div>
      <div class="pill" id="connPill">Firestore 연결: 확인 중…</div>
    </header>

    <div class="grid">
      <!-- LEFT: MAP -->
      <section class="panel" id="mapPanel">
        <div class="panelHeader">
          <div class="h">
            <b>캠퍼스 지도</b>
            <span>노드(16) + 랜드마크(6) · 연결선(SVG)</span>
          </div>
          <div class="pill" id="pathPill">…</div>
        </div>
        <div class="panelBody">
          <div class="campus" id="campus">
            <!-- SVG lines -->
            <svg id="lines" viewBox="0 0 1000 625" preserveAspectRatio="none" aria-hidden="true">
              <g stroke="rgba(255,255,255,.22)" stroke-width="2" fill="none">
                <path d="M130 140 C240 90, 320 90, 420 140" />
                <path d="M420 140 C520 200, 560 240, 600 330" />
                <path d="M600 330 C650 420, 720 470, 860 500" />
                <path d="M130 140 C120 250, 140 330, 220 410" />
                <path d="M220 410 C320 470, 420 480, 520 470" />
                <path d="M520 470 C610 470, 700 460, 780 420" />
                <path d="M420 140 C410 250, 420 340, 520 470" />
                <path d="M220 410 C250 320, 300 260, 360 220" />
                <path d="M360 220 C460 210, 520 230, 600 330" />
                <path d="M780 420 C720 350, 680 320, 600 330" />
              </g>
            </svg>

            <!-- Nodes + landmarks injected by JS -->
            <div class="overlay" id="overlay"></div>
          </div>
        </div>
      </section>

      <!-- RIGHT: PUZZLE + INFO -->
      <aside class="puzzleWrap">
        <div class="puzzle" id="puzzleBox" title="퍼즐 이미지 (타일 해금 표시)">
          <img src="assets/puzzle.png" alt="puzzle" />
          <div class="tiles" id="tiles"></div>
        </div>

        <div class="sideCard">
          <h3>라운드</h3>
          <p id="roundText">불러오는 중…</p>
        </div>

        <div class="sideCard">
          <h3>진행 현황</h3>
          <p id="progressText">불러오는 중…</p>
          <div class="progress">
            <div class="bar"><i id="barFill"></i></div>
            <div id="pct">0%</div>
          </div>
        </div>

        <div class="sideCard">
          <h3>WORLD</h3>
          <p>완성 이후 WORLD는 운영 정책에 따라 열 수 있습니다.</p>
          <p style="margin-top:10px;">
            <a href="world.html" style="text-decoration:underline; color: rgba(139,236,255,.90);">world.html 열기</a>
          </p>
        </div>
      </aside>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Modal -->
  <div class="modalBack" id="modalBack" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <b id="modalTitle">노드</b>
        <button class="x" id="closeModal" aria-label="닫기">✕</button>
      </div>
      <div class="modalBody">
        <div class="block">
          <div class="k">QUESTION</div>
          <div class="v" id="qText">…</div>

          <div class="hintToggle" id="hintToggle">▸ 힌트 보기</div>
          <div class="hintBox" id="hintBox">
            <div class="k">HINT</div>
            <div class="v" id="hText">…</div>
          </div>

          <div class="formRow">
            <input class="inp" id="answerInp" placeholder="정답 입력" autocomplete="off" />
            <button class="submit" id="submitBtn">확인</button>
          </div>
          <div class="status" id="statusLine"></div>
        </div>

        <div class="block">
          <div class="k">EXPLANATION (해금 후 표시)</div>
          <div class="v" id="eText" style="opacity:.85">아직 해금되지 않았습니다.</div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore,
      collection, doc,
      onSnapshot, getDoc,
      updateDoc, setDoc,
      runTransaction, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    /***********************
     * 0) Firebase Config
     ************************/
    const firebaseConfig = {
      apiKey: "REPLACE_ME",
      authDomain: "REPLACE_ME",
      projectId: "REPLACE_ME",
      storageBucket: "REPLACE_ME",
      messagingSenderId: "REPLACE_ME",
      appId: "REPLACE_ME",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    /***********************
     * 1) 경로 설정 (중요)
     *
     * 기본값: game/season1/rounds/R0001/slots/01~16
     *
     * 만약 네 구조가 진짜로 "season1/rounds/..."로 시작한다면:
     *  - 아래 BASE_PATH를 ["season1"]로 만들 수는 없고(문서경로 규칙상),
     *  - 반드시 컬렉션/문서 짝으로 맞춰야 함.
     *  - 보통은 game(컬렉션)/season1(문서) 구조라 이 코드가 맞는 케이스가 많음.
     ************************/
    const BASE_PATH = ["game", "season1"]; // ← 여기만 네 실제 최상단 구조에 맞춰 조정

    const connPill = document.getElementById("connPill");
    const pathPill = document.getElementById("pathPill");
    const roundText = document.getElementById("roundText");
    const progressText = document.getElementById("progressText");
    const barFill = document.getElementById("barFill");
    const pctEl = document.getElementById("pct");
    const toastEl = document.getElementById("toast");

    function toast(msg, kind=""){
      toastEl.textContent = msg;
      toastEl.className = "toast show " + (kind || "");
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=> toastEl.className = "toast", 2400);
    }

    /***********************
     * 2) 지도 데이터 (16 노드 + 6 랜드마크)
     * - 지금은 placeholder place. 네 실제 "기존 장소 유지"로 교체 가능
     ************************/
    const NODE_LIST = [
      { docId:"01", typeCode:"IFAP", place:"구역 A-1", x: 130, y: 140 },
      { docId:"02", typeCode:"IFAB", place:"구역 A-2", x: 360, y: 220 },
      { docId:"03", typeCode:"IFEP", place:"구역 A-3", x: 420, y: 140 },
      { docId:"04", typeCode:"IFEB", place:"구역 A-4", x: 540, y: 210 },
      { docId:"05", typeCode:"ILAP", place:"구역 B-1", x: 220, y: 410 },
      { docId:"06", typeCode:"ILAB", place:"구역 B-2", x: 380, y: 360 },
      { docId:"07", typeCode:"ILEP", place:"구역 B-3", x: 520, y: 470 },
      { docId:"08", typeCode:"ILEB", place:"구역 B-4", x: 640, y: 430 },
      { docId:"09", typeCode:"OFAP", place:"구역 C-1", x: 300, y: 520 },
      { docId:"10", typeCode:"OFAB", place:"구역 C-2", x: 460, y: 560 },
      { docId:"11", typeCode:"OFEP", place:"구역 C-3", x: 660, y: 560 },
      { docId:"12", typeCode:"OFEB", place:"구역 C-4", x: 780, y: 420 },
      { docId:"13", typeCode:"OLAP", place:"구역 D-1", x: 600, y: 330 },
      { docId:"14", typeCode:"OLAB", place:"구역 D-2", x: 720, y: 340 },
      { docId:"15", typeCode:"OLEP", place:"구역 D-3", x: 860, y: 500 },
      { docId:"16", typeCode:"OELB", place:"구역 D-4", x: 870, y: 250 },
    ];

    const LANDMARKS = [
      { name:"광장", x: 480, y: 300 },
      { name:"분수", x: 520, y: 310 },
      { name:"기숙사", x: 120, y: 260 },
      { name:"학생회관", x: 220, y: 260 },
      { name:"식당", x: 820, y: 320 },
      { name:"도서관", x: 760, y: 220 },
    ];

    /***********************
     * 3) 퍼즐 타일 생성 (4x4)
     ************************/
    const tilesEl = document.getElementById("tiles");
    const tileEls = new Map();
    for(let i=1;i<=16;i++){
      const t = document.createElement("div");
      t.className = "tile";
      t.dataset.i = String(i);
      tilesEl.appendChild(t);
      tileEls.set(i, t);
    }

    /***********************
     * 4) 지도 렌더
     ************************/
    const overlay = document.getElementById("overlay");
    const nodeDom = new Map();
    function pctX(x){ return (x/1000)*100; }
    function pctY(y){ return (y/625)*100; }

    function renderMapSkeleton(){
      overlay.innerHTML = "";

      for(const lm of LANDMARKS){
        const w = document.createElement("div");
        w.className = "landmark";
        w.style.left = pctX(lm.x) + "%";
        w.style.top  = pctY(lm.y) + "%";
        w.innerHTML = `<div class="lmPill"><span class="lmIcon"></span>${lm.name}</div>`;
        overlay.appendChild(w);
      }

      for(const n of NODE_LIST){
        const w = document.createElement("div");
        w.className = "node";
        w.style.left = pctX(n.x) + "%";
        w.style.top  = pctY(n.y) + "%";

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "nodeBtn";
        btn.innerHTML = `
          <span class="nodeDot"></span>
          <span class="nodeText">
            <b>${n.typeCode}</b>
            <span>${n.place}</span>
          </span>
        `;
        btn.addEventListener("click", () => openNodeModal(n.docId));
        w.appendChild(btn);

        overlay.appendChild(w);
        nodeDom.set(n.docId, { wrap:w, btn });
      }
    }
    renderMapSkeleton();

    /***********************
     * 5) Modal
     ************************/
    const modalBack = document.getElementById("modalBack");
    const modalTitle = document.getElementById("modalTitle");
    const closeModal = document.getElementById("closeModal");
    const qText = document.getElementById("qText");
    const hText = document.getElementById("hText");
    const eText = document.getElementById("eText");
    const hintToggle = document.getElementById("hintToggle");
    const hintBox = document.getElementById("hintBox");
    const answerInp = document.getElementById("answerInp");
    const submitBtn = document.getElementById("submitBtn");
    const statusLine = document.getElementById("statusLine");

    let currentDocId = null;
    let currentRoundId = null;

    closeModal.addEventListener("click", () => hideModal());
    modalBack.addEventListener("click", (e) => { if(e.target === modalBack) hideModal(); });
    window.addEventListener("keydown", (e)=> { if(e.key === "Escape" && modalBack.classList.contains("show")) hideModal(); });

    hintToggle.addEventListener("click", () => {
      const open = hintBox.classList.toggle("show");
      hintToggle.textContent = open ? "▾ 힌트 숨기기" : "▸ 힌트 보기";
    });

    function showModal(){ modalBack.classList.add("show"); answerInp.focus(); }
    function hideModal(){
      modalBack.classList.remove("show");
      currentDocId = null;
      answerInp.value = "";
      statusLine.className = "status";
      statusLine.textContent = "";
      hintBox.classList.remove("show");
      hintToggle.textContent = "▸ 힌트 보기";
    }

    function normalizeAnswer(s){
      return (s ?? "").toString().trim().replace(/\s+/g, " ").toLowerCase();
    }

    /***********************
     * 6) 자동 라운드 메타 문서
     * - BASE_PATH 아래에 meta 문서 1개: .../meta
     ************************/
    const metaRef = doc(db, ...BASE_PATH, "meta");

    async function ensureMeta(){
      const snap = await getDoc(metaRef);
      if(!snap.exists()){
        await setDoc(metaRef, {
          activeRoundId: "R0001",
          advancing: false,
          updatedAt: serverTimestamp()
        });
      }
    }

    function roundIdToNumber(rid){ return parseInt(String(rid).replace("R",""), 10); }
    function numberToRoundId(n){ return "R" + String(n).padStart(4, "0"); }

    function slotsColRef(roundId){
      // .../rounds/{roundId}/slots
      return collection(db, ...BASE_PATH, "rounds", roundId, "slots");
    }
    function slotDocRef(roundId, docId){
      // .../rounds/{roundId}/slots/{01..16}
      return doc(db, ...BASE_PATH, "rounds", roundId, "slots", docId);
    }

    /***********************
     * 7) 라운드 구독 (meta -> activeRoundId 변화에 따라 slots 재구독)
     ************************/
    let unsubscribeSlots = null;
    let lastUnlockedCount = -1;
    let completionAttemptedForRound = new Set(); // roundId별로 로컬 1회만 시도

    function subscribeSlots(roundId){
      if(unsubscribeSlots) unsubscribeSlots();
      currentRoundId = roundId;
      lastUnlockedCount = -1;

      const col = slotsColRef(roundId);
      pathPill.textContent = `${BASE_PATH.join("/")}/rounds/${roundId}/slots`;
      roundText.textContent = `현재 라운드: ${roundId}`;

      unsubscribeSlots = onSnapshot(col, async (qs) => {
        connPill.textContent = "Firestore 연결: 정상";
        connPill.style.borderColor = "rgba(140,255,200,.35)";

        // 문서 맵
        const byId = new Map();
        qs.forEach(s => byId.set(s.id, s.data()));

        // unlocked 반영 + 타일 반영
        let unlockedCount = 0;
        for(const n of NODE_LIST){
          const d = byId.get(n.docId);
          const isUnlocked = !!d?.unlocked;

          const dom = nodeDom.get(n.docId);
          if(dom) dom.wrap.classList.toggle("unlocked", isUnlocked);

          const idx = parseInt(n.docId, 10);
          const t = tileEls.get(idx);
          if(t) t.classList.toggle("revealed", isUnlocked);

          if(isUnlocked) unlockedCount++;
        }

        // 진행률
        const pct = Math.round((unlockedCount/16)*100);
        progressText.textContent = `${unlockedCount}/16 조각 해금`;
        barFill.style.width = pct + "%";
        pctEl.textContent = pct + "%";

        // 완료 감지 -> 자동 라운드 전환 트랜잭션
        if(unlockedCount === 16 && lastUnlockedCount !== 16){
          // 방금 막 완료된 순간(이 브라우저 기준) + 라운드당 로컬 1회만
          if(!completionAttemptedForRound.has(roundId)){
            completionAttemptedForRound.add(roundId);
            toast("라운드 완료! 다음 라운드 생성/전환 중…", "ok");
            try{
              await advanceRoundIfNeeded(roundId);
            }catch(e){
              console.error(e);
              toast("다음 라운드 전환 실패(권한/경로 확인)", "bad");
            }
          }
        }

        lastUnlockedCount = unlockedCount;
      }, (err) => {
        console.error(err);
        connPill.textContent = "Firestore 연결: 오류";
        connPill.style.borderColor = "rgba(255,122,122,.45)";
        toast("Firestore 오류(규칙/경로/config 확인)", "bad");
      });
    }

    // meta 구독: activeRoundId 바뀌면 자동으로 그 라운드로 붙는다
    await ensureMeta();
    onSnapshot(metaRef, (snap) => {
      if(!snap.exists()){
        toast("meta 문서 없음(자동 생성 시도했는데 실패)", "bad");
        return;
      }
      const m = snap.data();
      const rid = m.activeRoundId || "R0001";
      const adv = !!m.advancing;

      // 표시
      roundText.textContent = adv ? `현재 라운드: ${rid} (전환 중…)` : `현재 라운드: ${rid}`;

      // 라운드 바뀌면 재구독
      if(rid !== currentRoundId){
        subscribeSlots(rid);
        toast(`라운드 전환: ${rid}`, "ok");
      }
    });

    /***********************
     * 8) 모달 열기/정답 제출 (현재 라운드 기준)
     ************************/
    async function openNodeModal(docId){
      if(!currentRoundId){
        toast("라운드 정보 로딩 중…", "bad");
        return;
      }

      currentDocId = docId;
      statusLine.className = "status";
      statusLine.textContent = "불러오는 중…";
      eText.style.opacity = ".85";
      eText.textContent = "…";

      const ref = slotDocRef(currentRoundId, docId);
      const snap = await getDoc(ref);
      if(!snap.exists()){
        statusLine.className = "status bad";
        statusLine.textContent = "해당 문서가 없습니다. (01~16 확인)";
        showModal();
        return;
      }

      const d = snap.data();
      const nodeMeta = NODE_LIST.find(x => x.docId === docId);
      const titleLeft = nodeMeta?.typeCode ?? docId;
      const titleRight = d.positionName ? ` · ${d.positionName}` : "";
      modalTitle.textContent = `${titleLeft}${titleRight}`;

      qText.textContent = d.question ?? "(question 없음)";
      hText.textContent = d.hint ?? "(hint 없음)";

      const isUnlocked = !!d.unlocked;
      if(isUnlocked){
        statusLine.className = "status ok";
        statusLine.textContent = "이미 해금된 노드입니다.";
        eText.textContent = d.explanation ?? "(explanation 없음)";
        submitBtn.disabled = true;
        answerInp.disabled = true;
      }else{
        statusLine.className = "status";
        statusLine.textContent = "";
        eText.textContent = "아직 해금되지 않았습니다.";
        submitBtn.disabled = false;
        answerInp.disabled = false;
      }

      showModal();
    }

    async function trySubmit(){
      if(!currentRoundId || !currentDocId) return;

      const ref = slotDocRef(currentRoundId, currentDocId);
      const snap = await getDoc(ref);
      if(!snap.exists()) return;

      const d = snap.data();
      if(d.unlocked){
        statusLine.className = "status ok";
        statusLine.textContent = "방금 다른 사람이 먼저 해금했습니다.";
        submitBtn.disabled = true;
        answerInp.disabled = true;
        eText.textContent = d.explanation ?? "(explanation 없음)";
        return;
      }

      const userAns = normalizeAnswer(answerInp.value);
      const correct = normalizeAnswer(d.answer);

      if(!userAns){
        statusLine.className = "status bad";
        statusLine.textContent = "정답을 입력해줘.";
        return;
      }

      if(userAns === correct){
        await updateDoc(ref, { unlocked: true });
        statusLine.className = "status ok";
        statusLine.textContent = "정답! 이 노드는 해금되었습니다.";
        submitBtn.disabled = true;
        answerInp.disabled = true;
        eText.textContent = d.explanation ?? "(explanation 없음)";
      }else{
        statusLine.className = "status bad";
        statusLine.textContent = "오답. 다시 시도해줘.";
      }
    }

    submitBtn.addEventListener("click", trySubmit);
    answerInp.addEventListener("keydown", (e)=> { if(e.key === "Enter") trySubmit(); });

    /***********************
     * 9) 자동 라운드 전환 (트랜잭션, 중복 생성 방지)
     * - 조건: currentRoundId 라운드가 16/16 unlocked
     * - 동시 접속자 여러 명이어도 meta.advancing 락으로 1명만 생성
     * - 다음 라운드는 현재 라운드 슬롯을 "복사"하되 unlocked만 false로 초기화
     ************************/
    async function advanceRoundIfNeeded(roundIdJustCompleted){
      await runTransaction(db, async (tx) => {
        const metaSnap = await tx.get(metaRef);
        if(!metaSnap.exists()){
          tx.set(metaRef, {
            activeRoundId: "R0001",
            advancing: false,
            updatedAt: serverTimestamp()
          });
          throw new Error("meta was missing; created, retry later");
        }

        const meta = metaSnap.data();
        const active = meta.activeRoundId || "R0001";

        // 이미 다른 라운드로 넘어갔으면 아무것도 하지 않음
        if(active !== roundIdJustCompleted) return;

        // 이미 전환 중이면 아무것도 하지 않음
        if(meta.advancing) return;

        // 락
        tx.update(metaRef, { advancing: true, updatedAt: serverTimestamp() });

        // 다음 라운드
        const next = numberToRoundId(roundIdToNumber(active) + 1);

        // 현재 슬롯 16개 읽기 + 다음 라운드 슬롯 생성
        for(const n of NODE_LIST){
          const curRef = slotDocRef(active, n.docId);
          const curSnap = await tx.get(curRef);

          let baseData = {};
          if(curSnap.exists()){
            baseData = curSnap.data() || {};
          }else{
            // 슬롯 문서가 없는 경우 최소 스키마로 생성
            baseData = {
              typeCode: n.typeCode,
              positionName: "",
              difficulty: "",
              orderIndex: parseInt(n.docId, 10),
              claimed: false,
              claimerName: "",
              question: "",
              hint: "",
              answer: "",
              explanation: ""
            };
          }

          const nextRef = slotDocRef(next, n.docId);

          // 복사 + unlocked 초기화
          tx.set(nextRef, {
            ...baseData,
            unlocked: false,
            // 안전하게 orderIndex도 보정(문서가 꼬였을 때 대비)
            orderIndex: parseInt(n.docId, 10),
          }, { merge: true });
        }

        // rounds/{next} 문서도 생성(선택: 관리용)
        const nextRoundDoc = doc(db, ...BASE_PATH, "rounds", next);
        tx.set(nextRoundDoc, { createdAt: serverTimestamp() }, { merge: true });

        // activeRound 전환 + 락 해제
        tx.update(metaRef, {
          activeRoundId: next,
          advancing: false,
          updatedAt: serverTimestamp()
        });
      });

      toast("다음 라운드가 열렸습니다.", "ok");
    }

    // 연결 확인 타임아웃(대충)
    setTimeout(() => {
      if(connPill.textContent.includes("확인 중")){
        connPill.textContent = "Firestore 연결: 확인 필요 (config/권한)";
        connPill.style.borderColor = "rgba(255,122,122,.45)";
      }
    }, 1800);
  </script>
</body>
</html>
