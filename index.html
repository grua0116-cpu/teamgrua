<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GRUA 시즌 퍼즐</title>
  <style>
    :root{
      --bg:#0b0f19;
      --panel: rgba(255,255,255,.06);
      --panel2: rgba(255,255,255,.10);
      --line: rgba(255,255,255,.18);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: rgba(139, 236, 255, .95);
      --danger: rgba(255, 122, 122, .95);
      --ok: rgba(140, 255, 200, .95);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --radius2: 26px;
      --max: 1100px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background: radial-gradient(1200px 700px at 20% 10%, rgba(120,160,255,.12), transparent 55%),
                  radial-gradient(900px 600px at 80% 30%, rgba(140,255,200,.10), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo";
    }
    a{color:inherit}
    .wrap{
      max-width: var(--max);
      margin: 0 auto;
      padding: 22px 16px 60px;
    }
    header{
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 16px;
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .title h1{
      margin:0;
      font-size: 20px;
      letter-spacing: .2px;
    }
    .title p{
      margin:0;
      color:var(--muted);
      font-size: 13px;
      line-height: 1.35;
    }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .grid{
      display:grid;
      grid-template-columns: 1.25fr .75fr;
      gap: 14px;
      align-items:start;
    }
    @media (max-width: 980px){
      .grid{grid-template-columns: 1fr; }
    }

    /* Map panel */
    .panel{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--radius2);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap: 10px;
    }
    .panelHeader .h{
      display:flex;
      flex-direction:column;
      gap: 4px;
    }
    .panelHeader .h b{font-size: 14px;}
    .panelHeader .h span{font-size: 12px; color:var(--muted);}
    .panelBody{
      padding: 14px;
    }

    .campus{
      position:relative;
      aspect-ratio: 16 / 10;
      width:100%;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.10);
      overflow:hidden;
      background:
        radial-gradient(600px 350px at 30% 20%, rgba(120,160,255,.10), transparent 60%),
        radial-gradient(700px 400px at 75% 45%, rgba(140,255,200,.08), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    /* optional bg image */
    .campus::before{
      content:"";
      position:absolute; inset:0;
      background-image: url("assets/campus-bg.jpg");
      background-size: cover;
      background-position: center;
      opacity: .12;
      filter: saturate(.8) contrast(1.05);
      pointer-events:none;
    }
    .campus .overlay{
      position:absolute; inset:0;
      pointer-events:none;
    }
    .campus svg{
      position:absolute; inset:0;
      width:100%; height:100%;
      pointer-events:none;
    }
    .node, .landmark{
      position:absolute;
      transform: translate(-50%, -50%);
      pointer-events:auto;
      user-select:none;
    }
    .nodeBtn{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.55);
      backdrop-filter: blur(8px);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, background .12s ease, opacity .12s ease;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      min-width: 150px;
    }
    .nodeBtn:hover{ transform: translateY(-1px); border-color: rgba(139,236,255,.35); }
    .nodeDot{
      width:10px; height:10px;
      border-radius:999px;
      background: rgba(255,255,255,.55);
      box-shadow: 0 0 0 6px rgba(255,255,255,.08);
      flex:0 0 auto;
    }
    .nodeText{
      display:flex; flex-direction:column;
      gap:2px;
      min-width:0;
    }
    .nodeText b{
      font-size: 12px;
      letter-spacing: .3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .nodeText span{
      font-size: 11px;
      color: var(--muted);
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .node.unlocked .nodeDot{
      background: rgba(140,255,200,.95);
      box-shadow: 0 0 0 6px rgba(140,255,200,.12);
    }
    .node.unlocked .nodeBtn{
      border-color: rgba(140,255,200,.30);
      background: rgba(10,14,24,.40);
      opacity: .88;
    }
    .node.unlocked .nodeBtn:hover{ border-color: rgba(140,255,200,.45); }
    .node.lockedOut .nodeBtn{
      opacity: .45;
      cursor:not-allowed;
    }

    .lmPill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(8px);
      font-size: 12px;
      color: rgba(255,255,255,.80);
      pointer-events:none;
    }
    .lmIcon{
      width:10px; height:10px; border-radius: 3px;
      background: rgba(139,236,255,.70);
      box-shadow: 0 0 0 6px rgba(139,236,255,.08);
    }

    /* Puzzle panel */
    .puzzleWrap{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .puzzle{
      position:relative;
      width:100%;
      aspect-ratio: 1 / 1;
      border-radius: var(--radius2);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.03);
      box-shadow: var(--shadow);
    }
    .puzzle img{
      position:absolute; inset:0;
      width:100%; height:100%;
      object-fit:cover;
      transform: scale(1.02);
    }
    .tiles{
      position:absolute; inset:0;
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      grid-template-rows: repeat(4, 1fr);
      gap: 2px;
      padding: 2px;
      background: rgba(255,255,255,.05);
    }
    .tile{
      position:relative;
      overflow:hidden;
      border-radius: 10px;
      border:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.22);
    }
    .tile::before{
      content:"";
      position:absolute; inset:0;
      background-image: url("assets/puzzle.png");
      background-size: 400% 400%;
      filter: blur(16px) brightness(.8);
      opacity: .75;
      transform: scale(1.02);
    }
    .tile.revealed::before{
      filter: none;
      opacity: 1;
    }
    .tile[data-i="1"]::before  { background-position: 0%   0%; }
    .tile[data-i="2"]::before  { background-position: 33.333% 0%; }
    .tile[data-i="3"]::before  { background-position: 66.666% 0%; }
    .tile[data-i="4"]::before  { background-position: 100% 0%; }
    .tile[data-i="5"]::before  { background-position: 0%   33.333%; }
    .tile[data-i="6"]::before  { background-position: 33.333% 33.333%; }
    .tile[data-i="7"]::before  { background-position: 66.666% 33.333%; }
    .tile[data-i="8"]::before  { background-position: 100% 33.333%; }
    .tile[data-i="9"]::before  { background-position: 0%   66.666%; }
    .tile[data-i="10"]::before { background-position: 33.333% 66.666%; }
    .tile[data-i="11"]::before { background-position: 66.666% 66.666%; }
    .tile[data-i="12"]::before { background-position: 100% 66.666%; }
    .tile[data-i="13"]::before { background-position: 0%   100%; }
    .tile[data-i="14"]::before { background-position: 33.333% 100%; }
    .tile[data-i="15"]::before { background-position: 66.666% 100%; }
    .tile[data-i="16"]::before { background-position: 100% 100%; }

    .completeOverlay{
      position:absolute; inset:0;
      display:none;
      place-items:center;
      background: rgba(0,0,0,.30);
      backdrop-filter: blur(6px);
      cursor:pointer;
    }
    .completeOverlay.show{ display:grid; }
    .completeCard{
      width:min(92%, 360px);
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.60);
      box-shadow: var(--shadow);
      padding: 14px 14px 12px;
      text-align:center;
    }
    .completeCard b{ display:block; font-size: 14px; margin-bottom:6px;}
    .completeCard p{ margin:0; color:var(--muted); font-size: 12px; line-height:1.4;}
    .btnRow{ display:flex; gap:10px; justify-content:center; margin-top:10px;}
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 12px;
      font-size: 12px;
      cursor:pointer;
    }
    .btn:hover{ border-color: rgba(139,236,255,.35); }

    /* Right side small cards */
    .sideCard{
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--radius2);
      background: rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .sideCard h3{
      margin:0 0 6px 0;
      font-size: 13px;
    }
    .sideCard p{
      margin:0;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.45;
    }
    .progress{
      margin-top: 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      font-size: 12px;
      color: var(--muted);
    }
    .bar{
      flex:1;
      height: 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .bar > i{
      display:block;
      height:100%;
      width:0%;
      background: linear-gradient(90deg, rgba(139,236,255,.90), rgba(140,255,200,.90));
    }

    /* Modal */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      place-items:center;
      padding: 16px;
      z-index: 50;
    }
    .modalBack.show{ display:grid; }
    .modal{
      width:min(920px, 96vw);
      border-radius: 26px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.72);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalHead{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalHead b{font-size: 14px;}
    .x{
      width: 34px; height: 34px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      cursor:pointer;
    }
    .x:hover{ border-color: rgba(139,236,255,.35); }
    .modalBody{
      padding: 14px 16px 16px;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 12px;
    }
    @media (max-width: 860px){
      .modalBody{ grid-template-columns: 1fr; }
    }
    .block{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 20px;
      background: rgba(255,255,255,.04);
      padding: 12px;
    }
    .k{
      font-size: 11px; color: var(--muted);
      margin-bottom: 6px;
    }
    .v{
      font-size: 13px;
      line-height: 1.5;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .formRow{ display:flex; gap:10px; margin-top:10px; }
    .inp{
      flex:1;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      outline:none;
    }
    .inp:focus{ border-color: rgba(139,236,255,.35); }
    .submit{
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(139,236,255,.10);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      cursor:pointer;
      min-width: 92px;
    }
    .submit:hover{ border-color: rgba(139,236,255,.35); }
    .status{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .status.ok{ color: var(--ok); }
    .status.bad{ color: var(--danger); }
    .hintToggle{
      margin-top: 8px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      color: var(--muted);
      cursor:pointer;
      user-select:none;
    }
    .hintBox{ display:none; margin-top: 8px; }
    .hintBox.show{ display:block; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="title">
        <h1>GRUA · 시즌 1 공동 퍼즐</h1>
        <p>16개 타입 노드를 각각 해금하면 퍼즐이 완성됩니다. 로그인/닉네임/랭킹 없음. 기록보다 “해금 상태” 중심.</p>
      </div>
      <div class="pill" id="connPill">Firestore 연결: 확인 중…</div>
    </header>

    <div class="grid">
      <!-- LEFT: MAP -->
      <section class="panel" id="mapPanel">
        <div class="panelHeader">
          <div class="h">
            <b>캠퍼스 지도</b>
            <span>노드(16) + 랜드마크(6) · 연결선(SVG)</span>
          </div>
          <div class="pill" id="seasonPill">game/season1/slots</div>
        </div>
        <div class="panelBody">
          <div class="campus" id="campus">
            <!-- SVG lines -->
            <svg id="lines" viewBox="0 0 1000 625" preserveAspectRatio="none" aria-hidden="true">
              <g stroke="rgba(255,255,255,.22)" stroke-width="2" fill="none">
                <!-- 연결선: 좌표는 아래 nodePositions 기준(1000x625 공간) -->
                <!-- (원하는 모양대로 자유롭게 바꾸면 됨: 스펙 위반 아님, “연결선 존재”만 유지) -->
                <path d="M130 140 C240 90, 320 90, 420 140" />
                <path d="M420 140 C520 200, 560 240, 600 330" />
                <path d="M600 330 C650 420, 720 470, 860 500" />
                <path d="M130 140 C120 250, 140 330, 220 410" />
                <path d="M220 410 C320 470, 420 480, 520 470" />
                <path d="M520 470 C610 470, 700 460, 780 420" />
                <path d="M420 140 C410 250, 420 340, 520 470" />
                <path d="M220 410 C250 320, 300 260, 360 220" />
                <path d="M360 220 C460 210, 520 230, 600 330" />
                <path d="M780 420 C720 350, 680 320, 600 330" />
              </g>
            </svg>

            <!-- Nodes + landmarks injected by JS -->
            <div class="overlay" id="overlay"></div>
          </div>
        </div>
      </section>

      <!-- RIGHT: PUZZLE + INFO -->
      <aside class="puzzleWrap">
        <div class="puzzle" id="puzzleBox" title="완성 후 클릭하면 WORLD로 이동">
          <img src="assets/puzzle.png" alt="puzzle" />
          <div class="tiles" id="tiles"></div>

          <div class="completeOverlay" id="completeOverlay">
            <div class="completeCard">
              <b>ACCESS GRANTED</b>
              <p>16개 조각이 모두 해금되었습니다.<br/>퍼즐을 클릭하면 WORLD로 이동합니다.</p>
              <div class="btnRow">
                <button class="btn" id="goWorldBtn">WORLD로 이동</button>
              </div>
            </div>
          </div>
        </div>

        <div class="sideCard">
          <h3>진행 현황</h3>
          <p id="progressText">불러오는 중…</p>
          <div class="progress">
            <div class="bar"><i id="barFill"></i></div>
            <div id="pct">0%</div>
          </div>
        </div>

        <div class="sideCard">
          <h3>운영자 리셋 방식</h3>
          <p>
            다음 시즌은 자동 생성되지 않습니다.<br/>
            운영자가 <b>01~16 unlocked=false</b>로 리셋하고<br/>
            문제/힌트/정답 및 puzzle.png를 교체하면 새 시즌 시작입니다.
          </p>
        </div>
      </aside>
    </div>
  </div>

  <!-- Modal -->
  <div class="modalBack" id="modalBack" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <b id="modalTitle">노드</b>
        <button class="x" id="closeModal" aria-label="닫기">✕</button>
      </div>
      <div class="modalBody">
        <div class="block">
          <div class="k">QUESTION</div>
          <div class="v" id="qText">…</div>

          <div class="hintToggle" id="hintToggle">▸ 힌트 보기</div>
          <div class="hintBox" id="hintBox">
            <div class="k">HINT</div>
            <div class="v" id="hText">…</div>
          </div>

          <div class="formRow">
            <input class="inp" id="answerInp" placeholder="정답 입력" autocomplete="off" />
            <button class="submit" id="submitBtn">확인</button>
          </div>
          <div class="status" id="statusLine"></div>
        </div>

        <div class="block">
          <div class="k">EXPLANATION (해금 후 표시)</div>
          <div class="v" id="eText" style="opacity:.85">아직 해금되지 않았습니다.</div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    /***********************
     * 0) Firebase SDK
     ************************/
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore, collection, doc, onSnapshot, getDoc, updateDoc
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // TODO: 너의 Firebase 콘솔 값으로 교체
    const firebaseConfig = {
      apiKey: "REPLACE_ME",
      authDomain: "REPLACE_ME",
      projectId: "REPLACE_ME",
      storageBucket: "REPLACE_ME",
      messagingSenderId: "REPLACE_ME",
      appId: "REPLACE_ME",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    const connPill = document.getElementById("connPill");

    /***********************
     * 1) 고정 스펙: Firestore 경로
     ************************/
    const SLOTS_PATH = ["game", "season1", "slots"]; // game/season1/slots
    const slotsCol = collection(db, ...SLOTS_PATH);

    /***********************
     * 2) 타입 노드 16개 + 랜드마크 6개 (캠퍼스 배치)
     * - "기존 장소 유지"는 네가 가진 공식 좌표/이름으로 교체 가능
     * - 구조(16 타입 + 6 랜드마크) 자체는 고정 유지
     ************************/
    // 문서ID(01~16)와 orderIndex(1~16)는 1:1로 맞춰서 씀.
    // typeCode/positionName/difficulty는 표시용(있으면 보여주고, 없으면 fallback).
    const NODE_LIST = [
      { docId:"01", typeCode:"IFAP", place:"구역 A-1", x: 130, y: 140 },
      { docId:"02", typeCode:"IFAB", place:"구역 A-2", x: 360, y: 220 },
      { docId:"03", typeCode:"IFEP", place:"구역 A-3", x: 420, y: 140 },
      { docId:"04", typeCode:"IFEB", place:"구역 A-4", x: 540, y: 210 },

      { docId:"05", typeCode:"ILAP", place:"구역 B-1", x: 220, y: 410 },
      { docId:"06", typeCode:"ILAB", place:"구역 B-2", x: 380, y: 360 },
      { docId:"07", typeCode:"ILEP", place:"구역 B-3", x: 520, y: 470 },
      { docId:"08", typeCode:"ILEB", place:"구역 B-4", x: 640, y: 430 },

      { docId:"09", typeCode:"OFAP", place:"구역 C-1", x: 300, y: 520 },
      { docId:"10", typeCode:"OFAB", place:"구역 C-2", x: 460, y: 560 },
      { docId:"11", typeCode:"OFEP", place:"구역 C-3", x: 660, y: 560 },
      { docId:"12", typeCode:"OFEB", place:"구역 C-4", x: 780, y: 420 },

      { docId:"13", typeCode:"OLAP", place:"구역 D-1", x: 600, y: 330 },
      { docId:"14", typeCode:"OLAB", place:"구역 D-2", x: 720, y: 340 },
      { docId:"15", typeCode:"OLEP", place:"구역 D-3", x: 860, y: 500 },
      { docId:"16", typeCode:"OELB", place:"구역 D-4", x: 870, y: 250 },
    ];

    const LANDMARKS = [
      { name:"광장", x: 480, y: 300 },
      { name:"분수", x: 520, y: 310 },
      { name:"기숙사", x: 120, y: 260 },
      { name:"학생회관", x: 220, y: 260 },
      { name:"식당", x: 820, y: 320 },
      { name:"도서관", x: 760, y: 220 },
    ];

    /***********************
     * 3) 퍼즐 타일 생성 (4x4)
     ************************/
    const tilesEl = document.getElementById("tiles");
    const tileEls = new Map(); // orderIndex(1~16) -> el
    for(let i=1;i<=16;i++){
      const t = document.createElement("div");
      t.className = "tile";
      t.dataset.i = String(i);
      tilesEl.appendChild(t);
      tileEls.set(i, t);
    }

    /***********************
     * 4) 지도 렌더: 노드 + 랜드마크
     ************************/
    const overlay = document.getElementById("overlay");
    const nodeDom = new Map(); // docId -> {wrap, btn}
    function pctX(x){ return (x/1000)*100; }
    function pctY(y){ return (y/625)*100; }

    function renderMapSkeleton(){
      overlay.innerHTML = "";

      // landmarks (pointer-events none)
      for(const lm of LANDMARKS){
        const w = document.createElement("div");
        w.className = "landmark";
        w.style.left = pctX(lm.x) + "%";
        w.style.top  = pctY(lm.y) + "%";
        w.innerHTML = \`
          <div class="lmPill"><span class="lmIcon"></span>\${lm.name}</div>
        \`;
        overlay.appendChild(w);
      }

      // nodes (clickable)
      for(const n of NODE_LIST){
        const w = document.createElement("div");
        w.className = "node";
        w.style.left = pctX(n.x) + "%";
        w.style.top  = pctY(n.y) + "%";

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "nodeBtn";
        btn.innerHTML = \`
          <span class="nodeDot"></span>
          <span class="nodeText">
            <b>\${n.typeCode}</b>
            <span>\${n.place}</span>
          </span>
        \`;
        btn.addEventListener("click", () => openNodeModal(n.docId));
        w.appendChild(btn);

        overlay.appendChild(w);
        nodeDom.set(n.docId, { wrap:w, btn });
      }
    }
    renderMapSkeleton();

    /***********************
     * 5) 모달 / 정답 처리
     ************************/
    const modalBack = document.getElementById("modalBack");
    const modalTitle = document.getElementById("modalTitle");
    const closeModal = document.getElementById("closeModal");
    const qText = document.getElementById("qText");
    const hText = document.getElementById("hText");
    const eText = document.getElementById("eText");
    const hintToggle = document.getElementById("hintToggle");
    const hintBox = document.getElementById("hintBox");
    const answerInp = document.getElementById("answerInp");
    const submitBtn = document.getElementById("submitBtn");
    const statusLine = document.getElementById("statusLine");

    let currentDocId = null;
    let currentDocData = null;

    closeModal.addEventListener("click", () => hideModal());
    modalBack.addEventListener("click", (e) => {
      if(e.target === modalBack) hideModal();
    });
    window.addEventListener("keydown", (e)=> {
      if(e.key === "Escape" && modalBack.classList.contains("show")) hideModal();
    });

    hintToggle.addEventListener("click", () => {
      const open = hintBox.classList.toggle("show");
      hintToggle.textContent = open ? "▾ 힌트 숨기기" : "▸ 힌트 보기";
    });

    function showModal(){
      modalBack.classList.add("show");
      answerInp.focus();
    }
    function hideModal(){
      modalBack.classList.remove("show");
      currentDocId = null;
      currentDocData = null;
      answerInp.value = "";
      statusLine.className = "status";
      statusLine.textContent = "";
      hintBox.classList.remove("show");
      hintToggle.textContent = "▸ 힌트 보기";
    }

    async function openNodeModal(docId){
      currentDocId = docId;
      statusLine.className = "status";
      statusLine.textContent = "불러오는 중…";
      eText.style.opacity = ".85";
      eText.textContent = "…";

      const ref = doc(db, ...SLOTS_PATH, docId);
      const snap = await getDoc(ref);
      if(!snap.exists()){
        statusLine.className = "status bad";
        statusLine.textContent = "해당 문서가 Firestore에 없습니다. (01~16 확인)";
        return;
      }
      const d = snap.data();
      currentDocData = d;

      const nodeMeta = NODE_LIST.find(x => x.docId === docId);
      const titleLeft = nodeMeta?.typeCode ?? docId;
      const titleRight = d.positionName ? ` · ${d.positionName}` : "";
      modalTitle.textContent = `${titleLeft}${titleRight}`;

      qText.textContent = d.question ?? "(question 없음)";
      hText.textContent = d.hint ?? "(hint 없음)";

      const isUnlocked = !!d.unlocked;
      if(isUnlocked){
        statusLine.className = "status ok";
        statusLine.textContent = "이미 해금된 노드입니다.";
        eText.textContent = d.explanation ?? "(explanation 없음)";
        submitBtn.disabled = true;
        answerInp.disabled = true;
      }else{
        statusLine.className = "status";
        statusLine.textContent = "";
        eText.textContent = "아직 해금되지 않았습니다.";
        submitBtn.disabled = false;
        answerInp.disabled = false;
      }

      showModal();
    }

    function normalizeAnswer(s){
      return (s ?? "")
        .toString()
        .trim()
        .replace(/\s+/g, " ")
        .toLowerCase();
    }

    async function trySubmit(){
      if(!currentDocId || !currentDocData) return;

      const ref = doc(db, ...SLOTS_PATH, currentDocId);

      // 최신 상태 재확인 (동시성 최소화)
      const snap = await getDoc(ref);
      if(!snap.exists()) return;

      const d = snap.data();
      if(d.unlocked){
        statusLine.className = "status ok";
        statusLine.textContent = "방금 다른 사람이 먼저 해금했습니다.";
        submitBtn.disabled = true;
        answerInp.disabled = true;
        eText.textContent = d.explanation ?? "(explanation 없음)";
        return;
      }

      const userAns = normalizeAnswer(answerInp.value);
      const correct = normalizeAnswer(d.answer);

      if(!userAns){
        statusLine.className = "status bad";
        statusLine.textContent = "정답을 입력해줘.";
        return;
      }

      if(userAns === correct){
        await updateDoc(ref, { unlocked: true });
        statusLine.className = "status ok";
        statusLine.textContent = "정답! 이 노드는 해금되었습니다.";
        submitBtn.disabled = true;
        answerInp.disabled = true;
        eText.textContent = d.explanation ?? "(explanation 없음)";
      }else{
        statusLine.className = "status bad";
        statusLine.textContent = "오답. 다시 시도해줘.";
      }
    }

    submitBtn.addEventListener("click", trySubmit);
    answerInp.addEventListener("keydown", (e)=> {
      if(e.key === "Enter") trySubmit();
    });

    /***********************
     * 6) 실시간 구독: unlocked 상태로 UI 갱신
     ************************/
    const progressText = document.getElementById("progressText");
    const barFill = document.getElementById("barFill");
    const pctEl = document.getElementById("pct");
    const mapPanel = document.getElementById("mapPanel");
    const completeOverlay = document.getElementById("completeOverlay");
    const goWorldBtn = document.getElementById("goWorldBtn");
    const puzzleBox = document.getElementById("puzzleBox");

    function setCompleteUI(isComplete){
      if(isComplete){
        // 완료 시 자동으로: 노드/연결선/랜드마크 숨김 + puzzle 전면 표시 + 클릭 시 world.html
        mapPanel.style.display = "none";
        completeOverlay.classList.add("show");
      }else{
        mapPanel.style.display = "";
        completeOverlay.classList.remove("show");
      }
    }

    function goWorld(){
      window.location.href = "world.html";
    }
    goWorldBtn.addEventListener("click", goWorld);
    completeOverlay.addEventListener("click", goWorld);
    puzzleBox.addEventListener("click", () => {
      // 스펙: 완료 전에는 클릭해도 이동하지 않음
      if(completeOverlay.classList.contains("show")) goWorld();
    });

    // 16개 문서 실시간으로 본다 (단일 시즌 구조)
    const unsub = onSnapshot(slotsCol, (qs) => {
      connPill.textContent = "Firestore 연결: 정상";
      connPill.style.borderColor = "rgba(140,255,200,.35)";

      // 문서 맵 만들기
      const byId = new Map();
      qs.forEach(docSnap => byId.set(docSnap.id, docSnap.data()));

      // 진행률 계산: orderIndex(1~16) 기준
      let unlockedCount = 0;

      for(const n of NODE_LIST){
        const d = byId.get(n.docId);
        const isUnlocked = !!d?.unlocked;

        // 노드 스타일
        const dom = nodeDom.get(n.docId);
        if(dom){
          dom.wrap.classList.toggle("unlocked", isUnlocked);
        }

        // 타일 해금 (각 노드 1개 타일 대응 = orderIndex)
        // 여기서는 docId 01->1, 02->2 ... 16->16로 대응
        const idx = parseInt(n.docId, 10);
        const t = tileEls.get(idx);
        if(t){
          t.classList.toggle("revealed", isUnlocked);
        }

        if(isUnlocked) unlockedCount++;
      }

      const pct = Math.round((unlockedCount/16)*100);
      progressText.textContent = `${unlockedCount}/16 조각 해금`;
      barFill.style.width = pct + "%";
      pctEl.textContent = pct + "%";

      const complete = unlockedCount === 16;
      setCompleteUI(complete);
    }, (err) => {
      console.error(err);
      connPill.textContent = "Firestore 연결: 오류";
      connPill.style.borderColor = "rgba(255,122,122,.45)";
    });

    // 첫 로드 상태: 연결 확인 전
    setTimeout(() => {
      if(connPill.textContent.includes("확인 중")){
        connPill.textContent = "Firestore 연결: 확인 필요 (config/권한)";
        connPill.style.borderColor = "rgba(255,122,122,.45)";
      }
    }, 1800);
  </script>
</body>
</html>
