<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>GRUA · 공동 시즌 퍼즐</title>
  <style>
    :root{
      --bg:#0b0f19;
      --panel: rgba(255,255,255,.06);
      --line: rgba(255,255,255,.16);
      --text: rgba(255,255,255,.92);
      --muted: rgba(255,255,255,.65);
      --accent: rgba(139,236,255,.95);
      --ok: rgba(140,255,200,.95);
      --danger: rgba(255,122,122,.95);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --r: 26px;
      --r2: 18px;
      --max: 1100px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(120,160,255,.12), transparent 55%),
        radial-gradient(900px 600px at 80% 30%, rgba(140,255,200,.10), transparent 55%),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", Arial, "Apple SD Gothic Neo";
    }
    a{color:inherit}

    .wrap{ max-width: var(--max); margin: 0 auto; padding: 18px 14px 60px; }
    header{
      display:flex; align-items:flex-end; justify-content:space-between;
      gap:12px; margin-bottom: 12px;
    }
    .title{ display:flex; flex-direction:column; gap:6px; }
    .title h1{ margin:0; font-size: 20px; letter-spacing: .2px; }
    .title p{ margin:0; color:var(--muted); font-size: 13px; line-height: 1.35; }

    .pill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 12px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      border-radius: 999px;
      font-size: 12px;
      color: var(--muted);
      user-select:none;
      white-space:nowrap;
    }

    .panel{
      border:1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      display:flex; justify-content:space-between; align-items:center; gap: 10px;
    }
    .panelHeader .h{ display:flex; flex-direction:column; gap:4px; }
    .panelHeader .h b{ font-size: 14px; }
    .panelHeader .h span{ font-size: 12px; color: var(--muted); }

    .panelBody{ padding: 14px; }

    /* 지도 영역 */
    .campus{
      position:relative;
      width:100%;
      aspect-ratio: 16/9;
      border-radius: 22px;
      border:1px solid rgba(255,255,255,.10);
      overflow:hidden;
      background:
        radial-gradient(700px 400px at 30% 20%, rgba(120,160,255,.10), transparent 60%),
        radial-gradient(700px 420px at 75% 55%, rgba(140,255,200,.08), transparent 60%),
        linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    }
    .campus::before{
      content:"";
      position:absolute; inset:0;
      background-image: url("assets/campus-bg.jpg");
      background-size: cover;
      background-position: center;
      opacity: .10;
      filter: saturate(.85) contrast(1.05);
      pointer-events:none;
    }
    .campus svg{ position:absolute; inset:0; width:100%; height:100%; pointer-events:none; }
    .overlay{ position:absolute; inset:0; pointer-events:none; }

    /* 겹침 완화: 노드 버튼을 더 작게 + 폭 줄이기 + 줄바꿈 허용 */
    .node, .landmark{
      position:absolute;
      transform: translate(-50%,-50%);
      pointer-events:auto;
      user-select:none;
    }
    .nodeBtn{
      display:flex; align-items:flex-start; gap:10px;
      padding: 9px 10px;
      border-radius: 16px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.55);
      backdrop-filter: blur(8px);
      cursor:pointer;
      transition: transform .12s ease, border-color .12s ease, opacity .12s ease;
      box-shadow: 0 10px 24px rgba(0,0,0,.25);
      width: 138px;                /* ✅ 고정 폭 줄여 겹침 감소 */
      text-align:left;
    }
    .nodeBtn:hover{ transform: translateY(-1px); border-color: rgba(139,236,255,.35); }
    .nodeDot{
      width:10px; height:10px; border-radius:999px;
      background: rgba(255,255,255,.55);
      box-shadow: 0 0 0 6px rgba(255,255,255,.08);
      flex:0 0 auto;
      margin-top: 3px;
    }
    .nodeText{ display:flex; flex-direction:column; gap:2px; min-width:0; }
    .nodeText b{
      font-size: 12px;
      letter-spacing:.3px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .nodeText span{
      font-size: 11px;
      color: var(--muted);
      line-height: 1.25;
      white-space: normal;         /* ✅ 장소는 줄바꿈 허용 */
      overflow: hidden;
      display: -webkit-box;
      -webkit-line-clamp: 2;       /* ✅ 2줄까지만 */
      -webkit-box-orient: vertical;
    }
    .node.unlocked .nodeDot{
      background: rgba(140,255,200,.95);
      box-shadow: 0 0 0 6px rgba(140,255,200,.12);
    }
    .node.unlocked .nodeBtn{
      border-color: rgba(140,255,200,.30);
      opacity: .88;
    }

    .lmPill{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      backdrop-filter: blur(8px);
      font-size: 12px;
      color: rgba(255,255,255,.80);
      pointer-events:none;
      white-space:nowrap;
    }
    .lmIcon{
      width:10px; height:10px; border-radius: 3px;
      background: rgba(139,236,255,.70);
      box-shadow: 0 0 0 6px rgba(139,236,255,.08);
    }

    /* 지도 아래 상태 영역 */
    .statusGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
      margin-top: 12px;
    }
    @media (max-width: 860px){
      .statusGrid{ grid-template-columns: 1fr; }
    }
    .card{
      border:1px solid rgba(255,255,255,.10);
      border-radius: var(--r);
      background: rgba(255,255,255,.04);
      box-shadow: var(--shadow);
      padding: 14px;
    }
    .card h3{ margin:0 0 6px 0; font-size: 13px; }
    .card p{ margin:0; color: var(--muted); font-size: 12px; line-height: 1.45; }
    .progress{
      margin-top: 10px;
      display:flex; align-items:center; gap:10px; justify-content:space-between;
      font-size: 12px; color: var(--muted);
    }
    .bar{
      flex:1; height: 8px; border-radius: 999px;
      background: rgba(255,255,255,.08);
      overflow:hidden;
      border:1px solid rgba(255,255,255,.10);
    }
    .bar > i{
      display:block; height:100%; width:0%;
      background: linear-gradient(90deg, rgba(139,236,255,.90), rgba(140,255,200,.90));
    }

    /* 토스트 */
    .toast{
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      background: rgba(10,14,24,.78);
      border: 1px solid rgba(255,255,255,.14);
      color: rgba(255,255,255,.90);
      padding: 10px 12px;
      border-radius: 999px;
      box-shadow: var(--shadow);
      font-size: 12px;
      display:none;
      z-index: 60;
      backdrop-filter: blur(10px);
      max-width: min(92vw, 720px);
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .toast.show{ display:block; }
    .toast.ok{ border-color: rgba(140,255,200,.28); }
    .toast.bad{ border-color: rgba(255,122,122,.30); }

    /* 인트로 오버레이 */
    .introBack{
      position:fixed; inset:0;
      display:grid; place-items:center;
      padding: 18px;
      background: rgba(0,0,0,.62);
      z-index: 80;
    }
    .intro{
      width:min(920px, 96vw);
      border-radius: 28px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.78);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .introHead{
      padding: 18px 18px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .tag{
      display:inline-flex; align-items:center; gap:8px;
      padding: 8px 12px;
      border-radius: 999px;
      border:1px solid rgba(139,236,255,.30);
      background: rgba(139,236,255,.10);
      color: rgba(139,236,255,.95);
      font-size: 12px;
      letter-spacing:.2px;
    }
    .introHead h2{ margin: 10px 0 0; font-size: 18px; }
    .introHead p{ margin: 8px 0 0; color: var(--muted); font-size: 13px; line-height: 1.6; }
    .introBody{
      padding: 16px 18px 18px;
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      justify-content:flex-end;
      align-items:center;
    }
    .btn{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 14px;
      font-size: 13px;
      cursor:pointer;
    }
    .btn.primary{
      border-color: rgba(139,236,255,.30);
      background: rgba(139,236,255,.12);
    }
    .btn:hover{ border-color: rgba(139,236,255,.35); }

    /* 완료 퍼즐 오버레이 (노드 위로 뜸) */
    .puzzleBack{
      position:absolute; inset:0;
      display:none;
      place-items:center;
      background: rgba(0,0,0,.38);
      backdrop-filter: blur(6px);
      z-index: 40;
    }
    .puzzleBack.show{ display:grid; }
    .puzzleCard{
      width: min(92%, 620px);
      border-radius: 24px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.72);
      box-shadow: var(--shadow);
      overflow:hidden;
      cursor:pointer;
    }
    .puzzleTop{
      padding: 12px 14px;
      border-bottom: 1px solid rgba(255,255,255,.10);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
    }
    .puzzleTop b{ font-size: 13px; }
    .puzzleTop span{ font-size: 12px; color: var(--muted); }
    .puzzleImg{
      width:100%;
      aspect-ratio: 1/1;
      overflow:hidden;
      border-top: 1px solid rgba(255,255,255,.06);
      background: rgba(255,255,255,.03);
    }
    .puzzleImg img{
      width:100%; height:100%;
      object-fit:cover;
      display:block;
    }

    /* Modal */
    .modalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      place-items:center;
      padding: 16px;
      z-index: 70;
    }
    .modalBack.show{ display:grid; }
    .modal{
      width:min(920px, 96vw);
      border-radius: 26px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(10,14,24,.72);
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modalHead{
      display:flex; justify-content:space-between; align-items:center; gap:12px;
      padding: 14px 16px;
      border-bottom: 1px solid rgba(255,255,255,.10);
    }
    .modalHead b{ font-size: 14px; }
    .x{
      width: 34px; height: 34px;
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      cursor:pointer;
    }
    .x:hover{ border-color: rgba(139,236,255,.35); }
    .modalBody{
      padding: 14px 16px 16px;
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap: 12px;
    }
    @media (max-width: 860px){
      .modalBody{ grid-template-columns: 1fr; }
    }
    .block{
      border:1px solid rgba(255,255,255,.10);
      border-radius: 20px;
      background: rgba(255,255,255,.04);
      padding: 12px;
    }
    .k{ font-size: 11px; color: var(--muted); margin-bottom: 6px; }
    .v{ font-size: 13px; line-height: 1.5; white-space: pre-wrap; word-break: break-word; }
    .formRow{ display:flex; gap:10px; margin-top:10px; }
    .inp{
      flex:1;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      outline:none;
    }
    .inp:focus{ border-color: rgba(139,236,255,.35); }
    .submit{
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(139,236,255,.10);
      color: var(--text);
      padding: 10px 12px;
      font-size: 13px;
      cursor:pointer;
      min-width: 92px;
    }
    .submit:hover{ border-color: rgba(139,236,255,.35); }
    .submit:disabled{ opacity:.55; cursor:not-allowed; }
    .status{
      margin-top: 10px;
      font-size: 12px;
      color: var(--muted);
      min-height: 18px;
    }
    .status.ok{ color: var(--ok); }
    .status.bad{ color: var(--danger); }
    .hintToggle{
      margin-top: 8px;
      display:inline-flex;
      align-items:center;
      gap:8px;
      font-size: 12px;
      color: var(--muted);
      cursor:pointer;
      user-select:none;
    }
    .hintBox{ display:none; margin-top: 8px; }
    .hintBox.show{ display:block; }
  </style>
</head>

<body>
  <!-- 인트로 -->
  <div class="introBack" id="introBack">
    <div class="intro">
      <div class="introHead">
        <div class="tag">PROGRAM ON</div>
        <h2>GRUA · 공동 시즌 퍼즐</h2>
        <p>
          16명이 각자 1개의 노드를 해금하면 퍼즐이 완성됩니다.<br/>
          로그인/닉네임/랭킹 없이, “해금 상태”만으로 진행됩니다.
        </p>
      </div>
      <div class="introBody">
        <button class="btn" id="introClose">나중에</button>
        <button class="btn primary" id="introStart">START</button>
      </div>
    </div>
  </div>

  <div class="wrap">
    <header>
      <div class="title">
        <h1>GRUA · 공동 시즌 퍼즐</h1>
        <p>16개 타입 노드를 각각 해금하면 퍼즐이 완성됩니다. 로그인/닉네임/랭킹 없음.</p>
      </div>
      <div class="pill" id="connPill">Firestore 연결: 대기</div>
    </header>

    <section class="panel">
      <div class="panelHeader">
        <div class="h">
          <b>캠퍼스 지도</b>
          <span>노드(16) + 랜드마크(6) · 연결선(SVG)</span>
        </div>
        <div class="pill" id="pathPill">경로: -</div>
      </div>

      <div class="panelBody">
        <div class="campus" id="campus">
          <!-- 완료 퍼즐 오버레이 -->
          <div class="puzzleBack" id="puzzleBack" title="클릭하면 WORLD로 이동">
            <div class="puzzleCard" id="puzzleCard">
              <div class="puzzleTop">
                <b>ACCESS GRANTED</b>
                <span>퍼즐 클릭 → WORLD 진입</span>
              </div>
              <div class="puzzleImg">
                <img src="assets/puzzle.png" alt="puzzle" />
              </div>
            </div>
          </div>

          <!-- SVG lines -->
          <svg viewBox="0 0 1000 562.5" preserveAspectRatio="none" aria-hidden="true" id="lines">
            <g stroke="rgba(255,255,255,.20)" stroke-width="2" fill="none">
              <!-- 연결선: 필요하면 마음껏 조정 -->
              <path d="M120 120 C240 70, 320 70, 420 120" />
              <path d="M420 120 C540 190, 610 230, 650 300" />
              <path d="M650 300 C690 380, 760 430, 880 460" />
              <path d="M120 120 C110 220, 140 290, 220 360" />
              <path d="M220 360 C330 420, 430 430, 520 410" />
              <path d="M520 410 C610 410, 710 400, 790 360" />
              <path d="M420 120 C410 230, 430 320, 520 410" />
              <path d="M220 360 C260 290, 300 240, 360 200" />
              <path d="M360 200 C460 190, 540 220, 650 300" />
              <path d="M790 360 C730 310, 700 290, 650 300" />
            </g>
          </svg>

          <div class="overlay" id="overlay"></div>
        </div>

        <!-- 지도 아래 상태 영역 -->
        <div class="statusGrid">
          <div class="card">
            <h3>라운드</h3>
            <p id="roundText">불러오는 중…</p>
            <p id="advText" style="margin-top:8px; font-size:12px; color: rgba(255,255,255,.55);"></p>
          </div>

          <div class="card">
            <h3>진행 현황</h3>
            <p id="progressText">불러오는 중…</p>
            <div class="progress">
              <div class="bar"><i id="barFill"></i></div>
              <div id="pct">0%</div>
            </div>
          </div>
        </div>

      </div>
    </section>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Modal -->
  <div class="modalBack" id="modalBack" role="dialog" aria-modal="true">
    <div class="modal">
      <div class="modalHead">
        <b id="modalTitle">노드</b>
        <button class="x" id="closeModal" aria-label="닫기">✕</button>
      </div>
      <div class="modalBody">
        <div class="block">
          <div class="k">QUESTION</div>
          <div class="v" id="qText">…</div>

          <div class="hintToggle" id="hintToggle">▸ 힌트 보기</div>
          <div class="hintBox" id="hintBox">
            <div class="k">HINT</div>
            <div class="v" id="hText">…</div>
          </div>

          <div class="formRow">
            <input class="inp" id="answerInp" placeholder="정답 입력" autocomplete="off" />
            <button class="submit" id="submitBtn">확인</button>
          </div>
          <div class="status" id="statusLine"></div>
        </div>

        <div class="block">
          <div class="k">EXPLANATION (해금 후 표시)</div>
          <div class="v" id="eText" style="opacity:.85">아직 해금되지 않았습니다.</div>
        </div>
      </div>
    </div>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import {
      getFirestore,
      collection, doc,
      onSnapshot, getDoc,
      updateDoc, setDoc,
      runTransaction, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    /***********************
     * 0) Firebase Config
     ************************/
    const firebaseConfig = {
      apiKey: "REPLACE_ME",
      authDomain: "REPLACE_ME",
      projectId: "REPLACE_ME",
      storageBucket: "REPLACE_ME",
      messagingSenderId: "REPLACE_ME",
      appId: "REPLACE_ME",
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    /***********************
     * 1) Firestore Base Path (중요)
     * rounds 구조:
     *   BASE_PATH / rounds / {R0001} / slots / {01..16}
     *
     * meta 문서:
     *   BASE_PATH / meta / meta
     *
     * ✅ 대부분 이게 정답:
     *   ["game","season1"]  (game=컬렉션, season1=문서)
     ************************/
    const BASE_PATH = ["game", "season1"];  // <-- 너 구조에 맞게 필요시 수정

    /***********************
     * UI refs
     ************************/
    const connPill = document.getElementById("connPill");
    const pathPill = document.getElementById("pathPill");
    const roundText = document.getElementById("roundText");
    const advText = document.getElementById("advText");
    const progressText = document.getElementById("progressText");
    const barFill = document.getElementById("barFill");
    const pctEl = document.getElementById("pct");
    const toastEl = document.getElementById("toast");

    const introBack = document.getElementById("introBack");
    const introStart = document.getElementById("introStart");
    const introClose = document.getElementById("introClose");

    const puzzleBack = document.getElementById("puzzleBack");
    const puzzleCard = document.getElementById("puzzleCard");
    const linesSvg = document.getElementById("lines");

    function toast(msg, kind=""){
      toastEl.textContent = msg;
      toastEl.className = "toast show " + (kind || "");
      clearTimeout(toastEl._t);
      toastEl._t = setTimeout(()=> toastEl.className = "toast", 2600);
    }

    /***********************
     * 2) 노드/랜드마크 데이터
     * - 겹침 완화 위해 좌표를 조금 더 분산해둠(원하면 더 수정 가능)
     ************************/
    const NODE_LIST = [
      { docId:"01", typeCode:"IFAP", place:"구역 A-1", x: 120, y: 120 },
      { docId:"02", typeCode:"IFAB", place:"구역 A-2", x: 330, y: 210 },
      { docId:"03", typeCode:"IFEP", place:"구역 A-3", x: 440, y: 115 },
      { docId:"04", typeCode:"IFEB", place:"구역 A-4", x: 560, y: 170 },

      { docId:"05", typeCode:"ILAP", place:"구역 B-1", x: 190, y: 360 },
      { docId:"06", typeCode:"ILAB", place:"구역 B-2", x: 360, y: 325 },
      { docId:"07", typeCode:"ILEP", place:"구역 B-3", x: 470, y: 420 },
      { docId:"08", typeCode:"ILEB", place:"구역 B-4", x: 600, y: 400 },

      { docId:"09", typeCode:"OFAP", place:"구역 C-1", x: 280, y: 495 },
      { docId:"10", typeCode:"OFAB", place:"구역 C-2", x: 420, y: 515 },
      { docId:"11", typeCode:"OFEP", place:"구역 C-3", x: 600, y: 520 },
      { docId:"12", typeCode:"OFEB", place:"구역 C-4", x: 780, y: 380 },

      { docId:"13", typeCode:"OLAP", place:"구역 D-1", x: 650, y: 300 },
      { docId:"14", typeCode:"OLAB", place:"구역 D-2", x: 740, y: 300 },
      { docId:"15", typeCode:"OLEP", place:"구역 D-3", x: 845, y: 470 },
      { docId:"16", typeCode:"OELB", place:"구역 D-4", x: 880, y: 235 },
    ];

    const LANDMARKS = [
      { name:"광장", x: 500, y: 260 },
      { name:"분수", x: 540, y: 280 },
      { name:"기숙사", x: 120, y: 240 },
      { name:"학생회관", x: 240, y: 245 },
      { name:"식당", x: 820, y: 300 },
      { name:"도서관", x: 760, y: 210 },
    ];

    /***********************
     * 3) 지도 렌더
     ************************/
    const overlay = document.getElementById("overlay");
    const nodeDom = new Map();

    function pctX(x){ return (x/1000)*100; }
    function pctY(y){ return (y/562.5)*100; } // viewBox 높이와 맞춤

    function renderMapSkeleton(){
      overlay.innerHTML = "";
      nodeDom.clear();

      // 랜드마크
      for(const lm of LANDMARKS){
        const w = document.createElement("div");
        w.className = "landmark";
        w.style.left = pctX(lm.x) + "%";
        w.style.top  = pctY(lm.y) + "%";
        w.innerHTML = `<div class="lmPill"><span class="lmIcon"></span>${lm.name}</div>`;
        overlay.appendChild(w);
      }

      // 노드
      for(const n of NODE_LIST){
        const w = document.createElement("div");
        w.className = "node";
        w.style.left = pctX(n.x) + "%";
        w.style.top  = pctY(n.y) + "%";

        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "nodeBtn";
        btn.innerHTML = `
          <span class="nodeDot"></span>
          <span class="nodeText">
            <b>${n.typeCode}</b>
            <span>${n.place}</span>
          </span>
        `;
        btn.addEventListener("click", () => openNodeModal(n.docId));
        w.appendChild(btn);

        overlay.appendChild(w);
        nodeDom.set(n.docId, { wrap:w, btn });
      }
    }
    renderMapSkeleton();

    /***********************
     * 4) Modal
     ************************/
    const modalBack = document.getElementById("modalBack");
    const modalTitle = document.getElementById("modalTitle");
    const closeModal = document.getElementById("closeModal");
    const qText = document.getElementById("qText");
    const hText = document.getElementById("hText");
    const eText = document.getElementById("eText");
    const hintToggle = document.getElementById("hintToggle");
    const hintBox = document.getElementById("hintBox");
    const answerInp = document.getElementById("answerInp");
    const submitBtn = document.getElementById("submitBtn");
    const statusLine = document.getElementById("statusLine");

    let currentDocId = null;
    let currentRoundId = null;
    let completedThisRound = false;

    closeModal.addEventListener("click", () => hideModal());
    modalBack.addEventListener("click", (e) => { if(e.target === modalBack) hideModal(); });
    window.addEventListener("keydown", (e)=> { if(e.key === "Escape" && modalBack.classList.contains("show")) hideModal(); });

    hintToggle.addEventListener("click", () => {
      const open = hintBox.classList.toggle("show");
      hintToggle.textContent = open ? "▾ 힌트 숨기기" : "▸ 힌트 보기";
    });

    function showModal(){ modalBack.classList.add("show"); answerInp.focus(); }
    function hideModal(){
      modalBack.classList.remove("show");
      currentDocId = null;
      answerInp.value = "";
      statusLine.className = "status";
      statusLine.textContent = "";
      hintBox.classList.remove("show");
      hintToggle.textContent = "▸ 힌트 보기";
    }

    function normalizeAnswer(s){
      return (s ?? "").toString().trim().replace(/\s+/g, " ").toLowerCase();
    }

    /***********************
     * 5) Firestore refs
     ************************/
    // meta: BASE_PATH/meta/meta
    const metaRef = doc(db, ...BASE_PATH, "meta", "meta");

    function slotsColRef(roundId){
      // BASE_PATH/rounds/{roundId}/slots
      return collection(db, ...BASE_PATH, "rounds", roundId, "slots");
    }
    function slotDocRef(roundId, docId){
      // BASE_PATH/rounds/{roundId}/slots/{01..16}
      return doc(db, ...BASE_PATH, "rounds", roundId, "slots", docId);
    }
    function roundDocRef(roundId){
      return doc(db, ...BASE_PATH, "rounds", roundId);
    }

    function roundIdToNumber(rid){ return parseInt(String(rid).replace("R",""), 10); }
    function numberToRoundId(n){ return "R" + String(n).padStart(4, "0"); }

    async function ensureMeta(){
      const snap = await getDoc(metaRef);
      if(!snap.exists()){
        await setDoc(metaRef, {
          activeRoundId: "R0001",
          advancing: false,
          updatedAt: serverTimestamp()
        });
      }
    }

    /***********************
     * 6) 완료 퍼즐 오버레이 & WORLD 게이트
     ************************/
    function setCompleteUI(isComplete){
      completedThisRound = isComplete;

      if(isComplete){
        // 스펙: 완료 시 노드/연결선/랜드마크 숨김 + 퍼즐 전면 표시
        puzzleBack.classList.add("show");
        overlay.style.display = "none";
        linesSvg.style.display = "none";
      }else{
        puzzleBack.classList.remove("show");
        overlay.style.display = "";
        linesSvg.style.display = "";
      }
    }

    // 퍼즐 클릭 시: (1) 다음 라운드 자동화 시도 (2) world.html 이동
    puzzleCard.addEventListener("click", async () => {
      if(!completedThisRound || !currentRoundId) return;

      toast("WORLD 진입 준비 중…", "ok");

      // ✅ “다음 라운드 자동화”는 여기서 실행 (완료 직후 즉시 전환되면 퍼즐 화면이 사라지니까)
      try{
        await advanceRoundAndSwitch(currentRoundId);
      }catch(e){
        console.error(e);
        // 전환 실패해도 world는 들어가게 할지?
        // 여기선: 실패 토스트만 띄우고 world는 들어가게 함
        toast("다음 라운드 전환 실패(권한/경로 확인)", "bad");
      }

      window.location.href = "world.html";
    });

    /***********************
     * 7) 라운드 구독
     ************************/
    let unsubscribeSlots = null;
    let completionAttemptedForRound = new Set();

    function subscribeSlots(roundId){
      if(unsubscribeSlots) unsubscribeSlots();
      currentRoundId = roundId;
      completionAttemptedForRound.delete(roundId);
      setCompleteUI(false);

      const pathStr = `${BASE_PATH.join("/")}/rounds/${roundId}/slots`;
      pathPill.textContent = `경로: ${pathStr}`;
      roundText.textContent = `현재 라운드: ${roundId}`;
      advText.textContent = "";

      const col = slotsColRef(roundId);
      unsubscribeSlots = onSnapshot(col, async (qs) => {
        connPill.textContent = "Firestore 연결: 정상";
        connPill.style.borderColor = "rgba(140,255,200,.35)";

        const byId = new Map();
        qs.forEach(s => byId.set(s.id, s.data()));

        let unlockedCount = 0;

        for(const n of NODE_LIST){
          const d = byId.get(n.docId);
          const isUnlocked = !!d?.unlocked;

          const dom = nodeDom.get(n.docId);
          if(dom) dom.wrap.classList.toggle("unlocked", isUnlocked);

          if(isUnlocked) unlockedCount++;
        }

        const pct = Math.round((unlockedCount/16)*100);
        progressText.textContent = `${unlockedCount}/16 조각 해금`;
        barFill.style.width = pct + "%";
        pctEl.textContent = pct + "%";

        const complete = (unlockedCount === 16);
        setCompleteUI(complete);

        if(complete && !completionAttemptedForRound.has(roundId)){
          completionAttemptedForRound.add(roundId);
          toast("완료! 퍼즐이 열렸습니다. 퍼즐 클릭 → WORLD", "ok");
        }
      }, (err) => {
        console.error(err);
        connPill.textContent = "Firestore 연결: 오류";
        connPill.style.borderColor = "rgba(255,122,122,.45)";
        toast("Firestore 오류: 경로/규칙/firebaseConfig 확인", "bad");
      });
    }

    // meta 구독: activeRoundId 바뀌면 그 라운드로 붙음
    async function boot(){
      await ensureMeta();
      onSnapshot(metaRef, (snap) => {
        if(!snap.exists()){
          toast("meta 문서 없음(생성 실패)", "bad");
          return;
        }
        const m = snap.data();
        const rid = m.activeRoundId || "R0001";
        const adv = !!m.advancing;

        roundText.textContent = adv ? `현재 라운드: ${rid}` : `현재 라운드: ${rid}`;
        advText.textContent = adv ? "라운드 전환 중…" : "";

        if(rid !== currentRoundId){
          subscribeSlots(rid);
          toast(`라운드 로드: ${rid}`, "ok");
        }
      });

      // 연결 확인 타임아웃
      setTimeout(() => {
        if(connPill.textContent.includes("대기")){
          connPill.textContent = "Firestore 연결: 확인 필요 (config/권한)";
          connPill.style.borderColor = "rgba(255,122,122,.45)";
        }
      }, 2200);
    }

    /***********************
     * 8) 노드 모달 / 정답 제출
     ************************/
    async function openNodeModal(docId){
      if(completedThisRound){
        toast("이미 완료되었습니다. 퍼즐 클릭 → WORLD", "ok");
        return;
      }
      if(!currentRoundId){
        toast("라운드 로딩 중…", "bad");
        return;
      }

      currentDocId = docId;
      statusLine.className = "status";
      statusLine.textContent = "불러오는 중…";
      eText.textContent = "…";
      eText.style.opacity = ".85";

      const ref = slotDocRef(currentRoundId, docId);
      const snap = await getDoc(ref);
      if(!snap.exists()){
        statusLine.className = "status bad";
        statusLine.textContent = "문서가 없습니다. (01~16 확인)";
        showModal();
        return;
      }

      const d = snap.data();
      const nodeMeta = NODE_LIST.find(x => x.docId === docId);
      const titleLeft = nodeMeta?.typeCode ?? docId;
      const titleRight = d.positionName ? ` · ${d.positionName}` : "";
      modalTitle.textContent = `${titleLeft}${titleRight}`;

      qText.textContent = d.question ?? "(question 없음)";
      hText.textContent = d.hint ?? "(hint 없음)";

      if(!!d.unlocked){
        statusLine.className = "status ok";
        statusLine.textContent = "이미 해금된 노드입니다.";
        eText.textContent = d.explanation ?? "(explanation 없음)";
        submitBtn.disabled = true;
        answerInp.disabled = true;
      }else{
        statusLine.textContent = "";
        eText.textContent = "아직 해금되지 않았습니다.";
        submitBtn.disabled = false;
        answerInp.disabled = false;
      }

      showModal();
    }

    async function trySubmit(){
      if(!currentRoundId || !currentDocId) return;

      const ref = slotDocRef(currentRoundId, currentDocId);
      const snap = await getDoc(ref);
      if(!snap.exists()) return;

      const d = snap.data();
      if(d.unlocked){
        statusLine.className = "status ok";
        statusLine.textContent = "방금 다른 사람이 먼저 해금했습니다.";
        submitBtn.disabled = true;
        answerInp.disabled = true;
        eText.textContent = d.explanation ?? "(explanation 없음)";
        return;
      }

      const userAns = normalizeAnswer(answerInp.value);
      const correct = normalizeAnswer(d.answer);

      if(!userAns){
        statusLine.className = "status bad";
        statusLine.textContent = "정답을 입력해줘.";
        return;
      }

      if(userAns === correct){
        await updateDoc(ref, { unlocked: true });
        statusLine.className = "status ok";
        statusLine.textContent = "정답! 해금되었습니다.";
        submitBtn.disabled = true;
        answerInp.disabled = true;
        eText.textContent = d.explanation ?? "(explanation 없음)";
      }else{
        statusLine.className = "status bad";
        statusLine.textContent = "오답. 다시 시도해줘.";
      }
    }

    submitBtn.addEventListener("click", trySubmit);
    answerInp.addEventListener("keydown", (e)=> { if(e.key === "Enter") trySubmit(); });

    /***********************
     * 9) 다음 라운드 자동화 (트랜잭션, 중복 생성 방지)
     * - 퍼즐 클릭할 때 실행
     ************************/
    async function advanceRoundAndSwitch(roundIdJustCompleted){
      await runTransaction(db, async (tx) => {
        const metaSnap = await tx.get(metaRef);
        if(!metaSnap.exists()){
          tx.set(metaRef, {
            activeRoundId: "R0001",
            advancing: false,
            updatedAt: serverTimestamp()
          });
          throw new Error("meta missing; created. retry");
        }

        const meta = metaSnap.data();
        const active = meta.activeRoundId || "R0001";

        // 이미 다른 라운드로 넘어갔으면 끝
        if(active !== roundIdJustCompleted) return;

        // 이미 전환 중이면 끝
        if(meta.advancing) return;

        // 락
        tx.update(metaRef, { advancing: true, updatedAt: serverTimestamp() });

        const next = numberToRoundId(roundIdToNumber(active) + 1);

        // 다음 라운드 문서 생성(관리용)
        tx.set(roundDocRef(next), { createdAt: serverTimestamp() }, { merge: true });

        // 16 slots 복사 + unlocked=false 초기화
        for(const n of NODE_LIST){
          const curRef = slotDocRef(active, n.docId);
          const curSnap = await tx.get(curRef);

          let baseData = {};
          if(curSnap.exists()){
            baseData = curSnap.data() || {};
          }else{
            baseData = {
              typeCode: n.typeCode,
              positionName: "",
              difficulty: "",
              orderIndex: parseInt(n.docId, 10),
              claimed: false,
              claimerName: "",
              question: "",
              hint: "",
              answer: "",
              explanation: ""
            };
          }

          const nextRef = slotDocRef(next, n.docId);
          tx.set(nextRef, {
            ...baseData,
            unlocked: false,
            orderIndex: parseInt(n.docId, 10),
          }, { merge: true });
        }

        // activeRound 전환 + 락 해제
        tx.update(metaRef, {
          activeRoundId: next,
          advancing: false,
          updatedAt: serverTimestamp()
        });
      });

      toast("다음 라운드 생성/전환 완료", "ok");
    }

    /***********************
     * 10) 인트로 START 누르면 부트
     ************************/
    function startApp(){
      introBack.style.display = "none";
      connPill.textContent = "Firestore 연결: 대기";
      boot().catch((e)=>{
        console.error(e);
        toast("부팅 실패: firebaseConfig/경로 확인", "bad");
      });
    }

    introStart.addEventListener("click", startApp);
    introClose.addEventListener("click", () => {
      // 닫기 = 그냥 START와 동일하게 진입(사용자 경험상)
      startApp();
    });
  </script>
</body>
</html>
